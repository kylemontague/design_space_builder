<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radar Chart Design Space Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(to bottom right, #f8fafc, #e2e8f0);
            height: 100vh;
            padding: 0;
            overflow: hidden;
        }
        
        .app-layout {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 450px;
            background: white;
            border-right: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
        }

        .main-view {
            flex: 1;
            background: #f8fafc;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            overflow: auto;
            padding: 2rem;
        }
        
        .header {
            padding: 1.5rem;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .header h1 {
            font-size: 1.5rem;
            color: #1e293b;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.25rem;
        }
        
        .header h1:hover {
            background: #f8fafc;
        }
        
        .header input, .header textarea {
            width: 100%;
            padding: 0.5rem;
            border: 2px solid #3b82f6;
            border-radius: 0.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #0f172a;
        }
        
        .header textarea {
            font-size: 1rem;
            font-weight: normal;
            resize: vertical;
        }
        
        .description {
            color: #475569;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            padding: 0 0.5rem;
        }
        
        .tabs {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            overflow-x: auto;
            flex-shrink: 0;
        }
        
        .tab-button {
            padding: 1rem;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.875rem;
            color: #64748b;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }
        
        .tab-button.active {
            color: #3b82f6;
            border-bottom-color: #3b82f6;
        }
        
        .tab-button:hover {
            color: #1e293b;
        }
        
        .tab-content {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
        }
        
        .tab-panel {
            display: none;
        }
        
        .tab-panel.active {
            display: block;
        }
        
        .btn {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2563eb;
        }
        
        .btn-success {
            background: #10b981;
            color: white;
        }
        
        .btn-success:hover {
            background: #059669;
        }
        
        .btn-danger {
            background: #ef4444;
            color: white;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .btn-secondary {
            background: #475569; /* Darkened for contrast */
            color: white;
        }
        
        .btn-secondary:hover {
            background: #334155;
        }
        
        .btn:disabled {
            background: #94a3b8; /* Darkened for better visibility */
            cursor: not-allowed;
        }
        
        .card {
            background: #f8fafc;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .dimension-card, .datapoint-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .dimension-header, .datapoint-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.5rem;
        }
        
        .dimension-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #0f172a; /* Darker black/slate */
        }
        
        .btn-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .btn-icon {
            padding: 0.5rem;
            background: none;
            border: 1px solid transparent; /* Add transparent border for focus */
            cursor: pointer;
            border-radius: 0.25rem;
            color: #475569;
        }

        .btn-icon:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }
        
        .btn-icon:hover {
            background: #f1f5f9;
            color: #1e293b;
        }
        
        .btn-icon.danger:hover {
            background: #fee2e2;
            color: #dc2626;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #94a3b8; /* Darker border */
            border-radius: 0.5rem;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
            color: #0f172a;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
            border-color: #3b82f6;
        }
        
        label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600; /* Bolder */
            margin-bottom: 0.25rem;
            color: #334155; /* Darker slate */
        }
        
        .level-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 0.25rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .level-header {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .flex-1 {
            flex: 1;
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #64748b; /* Darker for contrast */
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .color-scheme {
            border: 2px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            cursor: pointer;
            margin-bottom: 1rem;
        }
        
        .color-scheme.active {
            border-color: #3b82f6;
        }
        
        .color-scheme:hover {
            border-color: #60a5fa;
        }
        
        .color-swatches {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }
        
        .color-swatch {
            width: 2rem;
            height: 2rem;
            border-radius: 0.25rem;
        }
        
        .grid {
            display: grid;
            gap: 1rem;
        }
        
        .grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }
        
        .grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .checkbox-label input {
            width: auto;
            margin: 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }
        
        th, td {
            border: 1px solid #cbd5e1;
            padding: 0.75rem;
            text-align: left;
        }
        
        th {
            background: #f1f5f9;
            font-weight: 600;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-swatch {
            width: 20px;
            height: 20px;
            border: 2px solid;
            border-radius: 0.25rem;
        }
        
        .datapoint-preview {
            position: relative;
            display: inline-block;
        }
        
        .datapoint-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #64748b;
            color: white;
            font-size: 0.625rem;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
        }
        
        .hidden-item {
            opacity: 0.5;
        }
        
        .size-presets {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .info-box {
            background: #dbeafe;
            border: 1px solid #93c5fd;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        #chartView, #chartExport {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        svg {
            max-width: 100%;
            height: auto;
            user-select: none;
        }

        .chart-container {
            width: 100%;
            max-width: 1000px;
        }

        .chart-controls {
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 1000px;
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <div class="sidebar">
            <div class="header">
                <div id="headerDisplay">
                    <h1 id="titleDisplay" onclick="editTitle()">Design Space</h1>
                    <p class="description" id="descDisplay"></p>
                    <p style="font-size: 0.75rem; color: #94a3b8; margin-top: 0.5rem; padding-left: 0.5rem;">Click to edit</p>
                </div>
                <div id="headerEdit" style="display: none;">
                    <input type="text" id="titleInput" value="Design Space">
                    <textarea id="descInput" rows="2" placeholder="Design space description (optional)"></textarea>
                    <button class="btn btn-primary" onclick="saveTitle()">Done</button>
                </div>
            </div>

            <div class="tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="switchTab('dimensions')">Dimensions</button>
                    <button class="tab-button" onclick="switchTab('datapoints')">Data</button>
                    <button class="tab-button" onclick="switchTab('theme')">Theme</button>
                    <button class="tab-button" onclick="switchTab('documentation')">Docs</button>
                    <button class="tab-button" onclick="switchTab('export')">Export</button>
                </div>

                <div class="tab-content">
                    <!-- Dimensions Tab -->
                    <div id="dimensions" class="tab-panel active">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h2>Dimensions</h2>
                            <button class="btn btn-success" onclick="addDimension()">+ Add</button>
                        </div>
                        <div id="dimensionsList"></div>
                    </div>

                    <!-- Data Points Tab -->
                    <div id="datapoints" class="tab-panel">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <div>
                                <h2>Data Points</h2>
                                <p style="font-size: 0.875rem; color: #64748b;" id="visibilityCount">0 of 0 visible</p>
                            </div>
                            <div class="btn-group">
                                <button class="btn btn-success" onclick="showAllDataPoints()">All</button>
                                <button class="btn btn-secondary" onclick="hideAllDataPoints()">None</button>
                                <button class="btn btn-primary" onclick="addDataPoint()">+ Add</button>
                            </div>
                        </div>
                        <div id="datapointsList"></div>
                    </div>

                    <!-- Theme Tab -->
                    <div id="theme" class="tab-panel">
                        <h2>Chart Size</h2>
                        <div class="grid grid-2" style="margin-bottom: 1rem;">
                            <div>
                                <label>Width (px)</label>
                                <input type="number" id="chartWidth" min="400" max="1600" step="50" value="800" onchange="saveState(); renderChart()">
                            </div>
                            <div>
                                <label>Height (px)</label>
                                <input type="number" id="chartHeight" min="400" max="1600" step="50" value="800" onchange="saveState(); renderChart()">
                            </div>
                        </div>
                        <div class="size-presets">
                            <button class="btn btn-secondary" onclick="setSize(800, 800)">Square</button>
                            <button class="btn btn-secondary" onclick="setSize(1000, 800)">Landscape</button>
                            <button class="btn btn-secondary" onclick="setSize(800, 1000)">Portrait</button>
                        </div>

                        <h2 style="margin-top: 2rem;">Color Scheme</h2>
                        <div class="grid grid-3" id="colorSchemes"></div>

                        <h2 style="margin-top: 2rem;">Label Visibility</h2>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showLevelLabels" checked onchange="saveState(); renderChart()">
                            <span>Show Level Labels</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showDimensionNames" checked onchange="saveState(); renderChart()">
                            <span>Show Dimension Names</span>
                        </label>
                    </div>

                    <!-- Documentation Tab -->
                    <div id="documentation" class="tab-panel">
                        <div id="documentationContent"></div>
                    </div>

                    <!-- Import/Export Tab -->
                    <div id="export" class="tab-panel">
                        <div class="card">
                            <h3 style="margin-bottom: 1rem;">Configuration (JSON)</h3>
                            <div class="btn-group">
                                <button class="btn btn-primary" onclick="exportJSON()">Export Config</button>
                                <button class="btn btn-success" onclick="document.getElementById('importFile').click()">Import</button>
                                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importJSON(event)">
                            </div>
                        </div>

                        <div class="card" style="margin-top: 1rem;">
                            <h3 style="margin-bottom: 1rem;">Chart Image (SVG)</h3>
                            <p style="font-size: 0.875rem; color: #64748b; margin-bottom: 1rem;">
                                Preview of the chart that will be exported.
                            </p>
                            <div id="chartExport"></div>
                            <button class="btn btn-primary" onclick="exportSVG()" style="margin-top: 1rem;">Export as SVG</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-view">
            <div class="chart-container">
                <div id="chartView"></div>
                <div id="chartLegend" class="legend"></div>
            </div>

            <div class="chart-controls">
                <div class="grid grid-2">
                    <div>
                        <h3 style="margin-bottom: 0.5rem;">Alt Text</h3>
                        <button class="btn btn-primary" onclick="generateAltText()">Generate</button>
                        <div id="altTextDisplay" style="margin-top: 1rem; display: none;">
                            <p style="font-size: 0.875rem; color: #475569;" id="altText"></p>
                            <button class="btn btn-success" onclick="copyText('altText')" style="margin-top: 0.5rem;">Copy</button>
                        </div>
                    </div>
                    <div>
                        <h3 style="margin-bottom: 0.5rem;">Caption</h3>
                        <button class="btn btn-primary" onclick="generateCaption()">Generate</button>
                        <div id="captionDisplay" style="margin-top: 1rem; display: none;">
                            <p style="font-size: 0.875rem; color: #475569;" id="caption"></p>
                            <button class="btn btn-success" onclick="copyText('caption')" style="margin-top: 0.5rem;">Copy</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State
        let state = {
            chartTitle: 'Design Space',
            description: '',
            dimensions: [],
            dataPoints: [],
            theme: {
                width: 800,
                height: 800,
                showLevelLabels: true,
                showDimensionNames: true,
                colorScheme: 'default'
            }
        };

        const colorSchemes = {
            default: ['#8884d8', '#82ca9d', '#ffc658', '#ff7c7c', '#8dd1e1', '#d084d0', '#a4de6c'],
            colorblind: ['#0173B2', '#DE8F05', '#029E73', '#CC78BC', '#CA9161', '#949494', '#ECE133'],
            monochrome: ['#1a1a1a', '#404040', '#666666', '#8c8c8c', '#b3b3b3', '#d9d9d9', '#f2f2f2'],
            warm: ['#D95F02', '#E7298A', '#E6AB02', '#A6761D', '#FF6B6B', '#FFA07A', '#FFD700'],
            cool: ['#1B9E77', '#66A61E', '#7570B3', '#6495ED', '#20B2AA', '#4682B4', '#5F9EA0']
        };

        let editingDimension = null;
        let editingDataPoint = null;
        let dragging = null;

        // Initialize
        function init() {
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
            // Prevent text selection while dragging
            document.addEventListener('selectstart', (e) => {
                if (dragging) e.preventDefault();
            });
            loadState();
            renderColorSchemes();
            render();
        }

        // State management
        function saveState() {
            localStorage.setItem('radarChartState', JSON.stringify(state));
        }

        function loadState() {
            const saved = localStorage.getItem('radarChartState');
            if (saved) {
                state = JSON.parse(saved);
                document.getElementById('titleInput').value = state.chartTitle;
                document.getElementById('descInput').value = state.description;
                document.getElementById('chartWidth').value = state.theme.width;
                document.getElementById('chartHeight').value = state.theme.height;
                document.getElementById('showLevelLabels').checked = state.theme.showLevelLabels;
                document.getElementById('showDimensionNames').checked = state.theme.showDimensionNames;
            }
        }

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            // Theme tab no longer needs specific render as chart is always visible
            if (tabName === 'documentation') renderDocumentation();
            if (tabName === 'export') renderExportPreview();
        }

        // Title editing
        function editTitle() {
            document.getElementById('headerDisplay').style.display = 'none';
            document.getElementById('headerEdit').style.display = 'block';
        }

        function saveTitle() {
            state.chartTitle = document.getElementById('titleInput').value;
            state.description = document.getElementById('descInput').value;
            document.getElementById('titleDisplay').textContent = state.chartTitle;
            document.getElementById('descDisplay').textContent = state.description;
            document.getElementById('headerDisplay').style.display = 'block';
            document.getElementById('headerEdit').style.display = 'none';
            saveState();
            renderChart(); // Update in case title is used in export filename or future chart rendering
        }

        // Dimensions
        function addDimension() {
            const id = state.dimensions.length;
            state.dimensions.push({
                id: id,
                name: 'New Dimension',
                description: '',
                levels: [
                    { id: 0, name: 'Low', description: '' },
                    { id: 1, name: 'Medium', description: '' },
                    { id: 2, name: 'High', description: '' }
                ]
            });
            saveState();
            renderDimensions();
            renderChart();
        }

        function editDimension(id) {
            editingDimension = id;
            renderDimensions();
        }

        function saveDimension() {
            editingDimension = null;
            saveState();
            renderDimensions();
            renderChart();
        }

        function deleteDimension(id) {
            if (confirm('Delete this dimension?')) {
                state.dimensions = state.dimensions.filter(d => d.id !== id);
                state.dimensions.forEach((d, i) => d.id = i);
                state.dataPoints.forEach(dp => {
                    delete dp.values[id];
                });
                saveState();
                renderDimensions();
                renderDataPoints();
                renderChart();
            }
        }

        function moveDimension(id, direction) {
            const idx = state.dimensions.findIndex(d => d.id === id);
            const newIdx = direction === 'up' ? idx - 1 : idx + 1;
            if (newIdx < 0 || newIdx >= state.dimensions.length) return;
            
            [state.dimensions[idx], state.dimensions[newIdx]] = [state.dimensions[newIdx], state.dimensions[idx]];
            saveState();
            renderDimensions();
            renderChart();
        }

        function addLevel(dimId) {
            const dim = state.dimensions.find(d => d.id === dimId);
            dim.levels.push({ id: dim.levels.length, name: 'New Level', description: '' });
            renderDimensions();
            renderChart();
        }

        function deleteLevel(dimId, levelId) {
            const dim = state.dimensions.find(d => d.id === dimId);
            if (dim.levels.length <= 2) return;
            dim.levels = dim.levels.filter(l => l.id !== levelId);
            dim.levels.forEach((l, i) => l.id = i);
            renderDimensions();
            renderChart();
        }

        function renderDimensions() {
            const container = document.getElementById('dimensionsList');
            
            if (state.dimensions.length === 0) {
                container.innerHTML = '<div class="empty-state">No dimensions yet. Click "Add Dimension" to get started.</div>';
                return;
            }

            container.innerHTML = state.dimensions.map((dim, idx) => {
                if (editingDimension === dim.id) {
                    return `
                        <div class="dimension-card">
                            <h4 style="margin-bottom: 1rem;">Editing Dimension</h4>
                            <label for="dim-name-${dim.id}">Name</label>
                            <input type="text" id="dim-name-${dim.id}" value="${dim.name}"
                                onchange="state.dimensions[${idx}].name = this.value">
                            <label for="dim-desc-${dim.id}">Description</label>
                            <textarea id="dim-desc-${dim.id}" rows="2" placeholder="Dimension description"
                                onchange="state.dimensions[${idx}].description = this.value">${dim.description}</textarea>
                            
                            <h5 style="margin-top: 1rem; margin-bottom: 0.5rem;">Levels</h5>
                            ${dim.levels.map((level, levelIdx) => `
                                <div class="level-item">
                                    <div class="level-header">
                                        <label for="dim-${dim.id}-lvl-${levelIdx}-name" class="visually-hidden">Level Name</label>
                                        <input type="text" id="dim-${dim.id}-lvl-${levelIdx}-name" class="flex-1" value="${level.name}"
                                            onchange="state.dimensions[${idx}].levels[${levelIdx}].name = this.value">
                                        ${dim.levels.length > 2 ? `
                                            <button class="btn btn-danger" aria-label="Delete Level" onclick="deleteLevel(${dim.id}, ${level.id})">√ó</button>
                                        ` : ''}
                                    </div>
                                    <label for="dim-${dim.id}-lvl-${levelIdx}-desc" class="visually-hidden">Level Description</label>
                                    <textarea id="dim-${dim.id}-lvl-${levelIdx}-desc" rows="2" placeholder="Level description"
                                        onchange="state.dimensions[${idx}].levels[${levelIdx}].description = this.value">${level.description}</textarea>
                                </div>
                            `).join('')}
                            <button class="btn btn-success" onclick="addLevel(${dim.id})">+ Add Level</button>
                            
                            <div class="btn-group" style="margin-top: 1rem;">
                                <button class="btn btn-primary" onclick="saveDimension()">Save</button>
                                <button class="btn btn-secondary" onclick="editingDimension = null; renderDimensions()">Cancel</button>
                            </div>
                        </div>
                    `;
                }

                return `
                    <div class="dimension-card">
                        <div class="dimension-header">
                            <div>
                                <div class="dimension-title">${dim.name}</div>
                                ${dim.description ? `<p style="font-size: 0.875rem; color: #64748b; margin-top: 0.25rem;">${dim.description}</p>` : ''}
                                <p style="font-size: 0.875rem; color: #94a3b8; margin-top: 0.25rem;">${dim.levels.length} levels</p>
                            </div>
                            <div class="btn-group">
                                <button class="btn-icon" onclick="moveDimension(${dim.id}, 'up')" ${idx === 0 ? 'disabled' : ''}>‚Üë</button>
                                <button class="btn-icon" onclick="moveDimension(${dim.id}, 'down')" ${idx === state.dimensions.length - 1 ? 'disabled' : ''}>‚Üì</button>
                                <button class="btn-icon" onclick="editDimension(${dim.id})">‚úé</button>
                                <button class="btn-icon danger" onclick="deleteDimension(${dim.id})">√ó</button>
                            </div>
                        </div>
                        <div style="margin-top: 1rem;">
                            ${dim.levels.map(level => `
                                <div style="font-size: 0.875rem; margin-bottom: 0.25rem;">
                                    <strong>${level.name}</strong>${level.description ? ` - ${level.description}` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Data Points
        function addDataPoint() {
            if (state.dimensions.length === 0) {
                alert('Please add dimensions first.');
                return;
            }

            const id = state.dataPoints.length;
            const values = {};
            state.dimensions.forEach(dim => values[dim.id] = 0);
            
            state.dataPoints.push({
                id: id,
                name: `Data Point ${id + 1}`,
                visible: true,
                values: values
            });
            saveState();
            renderDataPoints();
            renderChart();
        }

        function editDataPoint(id) {
            editingDataPoint = id;
            renderDataPoints();
        }

        function saveDataPoint() {
            editingDataPoint = null;
            saveState();
            renderDataPoints();
            renderChart();
        }

        function deleteDataPoint(id) {
            if (confirm('Delete this data point?')) {
                state.dataPoints = state.dataPoints.filter(dp => dp.id !== id);
                state.dataPoints.forEach((dp, i) => dp.id = i);
                saveState();
                renderDataPoints();
                renderChart();
            }
        }

        function toggleVisibility(id) {
            const dp = state.dataPoints.find(d => d.id === id);
            dp.visible = !dp.visible;
            saveState();
            renderDataPoints();
            renderChart();
        }

        function showAllDataPoints() {
            state.dataPoints.forEach(dp => dp.visible = true);
            saveState();
            renderDataPoints();
            renderChart();
        }

        function hideAllDataPoints() {
            state.dataPoints.forEach(dp => dp.visible = false);
            saveState();
            renderDataPoints();
            renderChart();
        }

        function renderDataPoints() {
            const visibleCount = state.dataPoints.filter(dp => dp.visible).length;
            document.getElementById('visibilityCount').textContent = `${visibleCount} of ${state.dataPoints.length} visible`;

            const container = document.getElementById('datapointsList');
            
            if (state.dataPoints.length === 0) {
                container.innerHTML = state.dimensions.length === 0 
                    ? '<div class="empty-state">Add dimensions first before creating data points.</div>'
                    : '<div class="empty-state">No data points yet. Click "Add Data Point" to create one.</div>';
                return;
            }

            container.innerHTML = state.dataPoints.map((dp, idx) => {
                const color = colorSchemes[state.theme.colorScheme][idx % colorSchemes[state.theme.colorScheme].length];
                
                if (editingDataPoint === dp.id) {
                    return `
                        <div class="datapoint-card">
                            <label for="dp-name-${dp.id}">Name</label>
                            <input type="text" id="dp-name-${dp.id}" value="${dp.name}"
                                onchange="state.dataPoints[${idx}].name = this.value">
                            
                            ${state.dimensions.map(dim => `
                                <div style="margin-top: 1rem;">
                                    <label for="dp-${dp.id}-dim-${dim.id}">${dim.name}</label>
                                    <select id="dp-${dp.id}-dim-${dim.id}" onchange="state.dataPoints[${idx}].values[${dim.id}] = parseInt(this.value)">
                                        ${dim.levels.map(level => `
                                            <option value="${level.id}" ${dp.values[dim.id] === level.id ? 'selected' : ''}>
                                                ${level.name}
                                            </option>
                                        `).join('')}
                                    </select>
                                </div>
                            `).join('')}
                            
                            <div class="btn-group" style="margin-top: 1rem;">
                                <button class="btn btn-primary" onclick="saveDataPoint()">Save</button>
                                <button class="btn btn-secondary" onclick="editingDataPoint = null; renderDataPoints()">Cancel</button>
                            </div>
                        </div>
                    `;
                }

                return `
                    <div class="datapoint-card ${!dp.visible ? 'hidden-item' : ''}">
                        <div class="dimension-header">
                            <div style="display: flex; align-items: start; gap: 1rem;">
                                <div class="datapoint-preview">
                                    <div style="width: 2rem; height: 2rem; border: 2px solid ${color}; background: ${color}; opacity: 0.5; border-radius: 0.25rem;"></div>
                                    ${!dp.visible ? '<span class="datapoint-badge">Hidden</span>' : ''}
                                </div>
                                <div>
                                    <div class="dimension-title">${dp.name}</div>
                                    <div style="font-size: 0.875rem; color: #64748b; margin-top: 0.5rem;">
                                        ${state.dimensions.map(dim => {
                                            const level = dim.levels[dp.values[dim.id] || 0];
                                            return `<div><strong>${dim.name}:</strong> ${level.name}</div>`;
                                        }).join('')}
                                    </div>
                                </div>
                            </div>
                            <div class="btn-group">
                                <button class="btn-icon" onclick="toggleVisibility(${dp.id})">${dp.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}</button>
                                <button class="btn-icon" onclick="editDataPoint(${dp.id})">‚úé</button>
                                <button class="btn-icon danger" onclick="deleteDataPoint(${dp.id})">√ó</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Theme
        function renderColorSchemes() {
            const container = document.getElementById('colorSchemes');
            container.innerHTML = Object.entries(colorSchemes).map(([key, colors]) => `
                <div class="color-scheme ${state.theme.colorScheme === key ? 'active' : ''}" 
                     onclick="state.theme.colorScheme = '${key}'; saveState(); renderColorSchemes(); renderChart();">
                    <div style="font-weight: 500; text-transform: capitalize;">${key}</div>
                    <div class="color-swatches">
                        ${colors.map(color => `<div class="color-swatch" style="background: ${color};"></div>`).join('')}
                    </div>
                </div>
            `).join('');
        }

        function setSize(width, height) {
            state.theme.width = width;
            state.theme.height = height;
            document.getElementById('chartWidth').value = width;
            document.getElementById('chartHeight').value = height;
            saveState();
            renderChart();
        }

        // Drag and Drop Interaction
        function startDrag(e, dpIdx, dimId) {
            if (e.button !== 0) return; // Only left click
            dragging = { dpIdx, dimId };
            e.preventDefault();
        }

        function handleDrag(e) {
            if (!dragging) return;

            const svg = document.querySelector('#chartView svg');
            if (!svg) return;

            const rect = svg.getBoundingClientRect();
            const scale = 1; // Main view is always scale 1

            // Calculate mouse position relative to SVG center
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const width = state.theme.width * scale;
            const height = state.theme.height * scale;
            const centerX = width / 2;
            const centerY = height / 2;
            const minDim = Math.min(width, height);
            const minRadius = minDim * 0.1;
            const maxRadius = minDim * 0.31;

            // Calculate distance from center
            const dx = mouseX - centerX;
            const dy = mouseY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Map distance to level
            // distance = minRadius + (level / maxLevel) * (maxRadius - minRadius)
            // level / maxLevel = (distance - minRadius) / (maxRadius - minRadius)

            const dim = state.dimensions.find(d => d.id === dragging.dimId);
            if (!dim) return;

            const maxLevel = dim.levels.length - 1;
            let level = Math.round(((distance - minRadius) / (maxRadius - minRadius)) * maxLevel);

            // Clamp level
            level = Math.max(0, Math.min(level, maxLevel));

            // Update state
            // We need to find the actual data point object since visibleDataPoints logic might complicate index
            const visibleDataPoints = state.dataPoints.filter(dp => dp.visible);
            if (dragging.dpIdx < 0 || dragging.dpIdx >= visibleDataPoints.length) return;

            const dp = visibleDataPoints[dragging.dpIdx];
            dp.values[dragging.dimId] = level;

            // Force render
            // We don't save state on every move to avoid thrashing localStorage,
            // but we do render to show the update
            renderChart();
            // Update sidebar inputs to reflect changes
            renderDataPoints();
        }

        function stopDrag() {
            if (dragging) {
                dragging = null;
                saveState(); // Save final position
                renderDataPoints(); // Ensure sidebar is in sync final state
            }
        }

        function handleKeyDown(e, dpIdx, dimId) {
            const dim = state.dimensions.find(d => d.id === dimId);
            if (!dim) return;

            // We need to access the correct data point from the *visible* list context or the main list
            // The render loop passes dpIdx as the index in the visible list, but we also need to know
            // which actual data point it refers to.
            // Actually, looking at render loop:
            const visibleDataPoints = state.dataPoints.filter(dp => dp.visible);
            const dp = visibleDataPoints[dpIdx]; // This assumes dpIdx matches the visible list index

            if (!dp) return;

            let currentLevel = dp.values[dimId] || 0;
            const maxLevel = dim.levels.length - 1;
            let changed = false;

            if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
                if (currentLevel < maxLevel) {
                    currentLevel++;
                    changed = true;
                }
            } else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
                if (currentLevel > 0) {
                    currentLevel--;
                    changed = true;
                }
            }

            if (changed) {
                e.preventDefault(); // Prevent scrolling
                dp.values[dimId] = currentLevel;
                saveState();
                renderChart();
                renderDataPoints();

                // Restore focus to the handle
                // Since re-render destroys DOM elements, we need to re-focus.
                // We can try to focus the element with matching ID or attributes after render.
                requestAnimationFrame(() => {
                    const selector = `circle[data-dp-idx="${dpIdx}"][data-dim-id="${dimId}"]`;
                    const el = document.querySelector(selector);
                    if (el) el.focus();
                });
            }
        }

        // Chart rendering
        function renderRadarChart(container, scale = 1, interactive = true) {
            if (state.dimensions.length === 0) {
                container.innerHTML = '<div class="empty-state">Add dimensions to see the chart</div>';
                return null;
            }

            state.theme.width = parseInt(document.getElementById('chartWidth').value);
            state.theme.height = parseInt(document.getElementById('chartHeight').value);
            state.theme.showLevelLabels = document.getElementById('showLevelLabels').checked;
            state.theme.showDimensionNames = document.getElementById('showDimensionNames').checked;

            const width = state.theme.width * scale;
            const height = state.theme.height * scale;
            const centerX = width / 2;
            const centerY = height / 2;
            const minDim = Math.min(width, height);
            const minRadius = minDim * 0.1;
            const maxRadius = minDim * 0.31;
            const axisExtension = minDim * 0.075;

            const colors = colorSchemes[state.theme.colorScheme];
            const visibleDataPoints = state.dataPoints.filter(dp => dp.visible);

            const patterns = ['solid', 'horizontal', 'vertical', 'diagonal-right', 'diagonal-left', 'crosshatch', 'dots'];

            // Add slight rotation offset (15 degrees) to prevent perfectly horizontal lines
            const rotationOffset = Math.PI / 12;
            const getAngle = (index, total) => (index * 2 * Math.PI) / total - Math.PI / 2 + rotationOffset;
            const getPoint = (angle, distance) => ({
                x: centerX + distance * Math.cos(angle),
                y: centerY + distance * Math.sin(angle)
            });

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

            // Define patterns
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            visibleDataPoints.forEach((dp, idx) => {
                const color = colors[idx % colors.length];
                const patternType = patterns[idx % patterns.length];
                
                if (patternType !== 'solid') {
                    const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                    pattern.setAttribute('id', `pattern-${dp.id}`);
                    pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                    pattern.setAttribute('width', '8');
                    pattern.setAttribute('height', '8');

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('width', '8');
                    rect.setAttribute('height', '8');
                    rect.setAttribute('fill', color);
                    rect.setAttribute('opacity', '0.3');
                    pattern.appendChild(rect);

                    if (patternType === 'horizontal') {
                        ['2', '6'].forEach(y => {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', '0'); line.setAttribute('y1', y);
                            line.setAttribute('x2', '8'); line.setAttribute('y2', y);
                            line.setAttribute('stroke', color); line.setAttribute('stroke-width', '1');
                            pattern.appendChild(line);
                        });
                    } else if (patternType === 'vertical') {
                        ['2', '6'].forEach(x => {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', x); line.setAttribute('y1', '0');
                            line.setAttribute('x2', x); line.setAttribute('y2', '8');
                            line.setAttribute('stroke', color); line.setAttribute('stroke-width', '1');
                            pattern.appendChild(line);
                        });
                    } else if (patternType === 'diagonal-right') {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', '0'); line.setAttribute('y1', '8');
                        line.setAttribute('x2', '8'); line.setAttribute('y2', '0');
                        line.setAttribute('stroke', color); line.setAttribute('stroke-width', '1');
                        pattern.appendChild(line);
                    } else if (patternType === 'diagonal-left') {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', '0'); line.setAttribute('y1', '0');
                        line.setAttribute('x2', '8'); line.setAttribute('y2', '8');
                        line.setAttribute('stroke', color); line.setAttribute('stroke-width', '1');
                        pattern.appendChild(line);
                    } else if (patternType === 'crosshatch') {
                        const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line1.setAttribute('x1', '0'); line1.setAttribute('y1', '0');
                        line1.setAttribute('x2', '8'); line1.setAttribute('y2', '8');
                        line1.setAttribute('stroke', color); line1.setAttribute('stroke-width', '1');
                        const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line2.setAttribute('x1', '0'); line2.setAttribute('y1', '8');
                        line2.setAttribute('x2', '8'); line2.setAttribute('y2', '0');
                        line2.setAttribute('stroke', color); line2.setAttribute('stroke-width', '1');
                        pattern.appendChild(line1); pattern.appendChild(line2);
                    } else if (patternType === 'dots') {
                        [[2, 2], [6, 6]].forEach(([cx, cy]) => {
                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', cx); circle.setAttribute('cy', cy);
                            circle.setAttribute('r', '1'); circle.setAttribute('fill', color);
                            pattern.appendChild(circle);
                        });
                    }

                    defs.appendChild(pattern);
                }
            });
            svg.appendChild(defs);

            // LAYER 1: Data Polygons (Behind everything)
            visibleDataPoints.forEach((dp, dpIdx) => {
                const color = colors[dpIdx % colors.length];
                const patternType = patterns[dpIdx % patterns.length];

                const points = state.dimensions.map((dim, idx) => {
                    const angle = getAngle(idx, state.dimensions.length);
                    const levelValue = dp.values[dim.id] || 0;
                    const distance = minRadius + (levelValue / (dim.levels.length - 1)) * (maxRadius - minRadius);
                    return getPoint(angle, distance);
                });

                const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ') + ' Z';
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD);
                path.setAttribute('fill', patternType === 'solid' ? color : `url(#pattern-${dp.id})`);
                path.setAttribute('fill-opacity', patternType === 'solid' ? '0.3' : '1');
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', 2 * scale);
                svg.appendChild(path);
            });

            // LAYER 2: Axes, Levels, Labels (On top of polygons)
            state.dimensions.forEach((dim, idx) => {
                const angle = getAngle(idx, state.dimensions.length);
                const endPoint = getPoint(angle, maxRadius + axisExtension);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', centerX); line.setAttribute('y1', centerY);
                line.setAttribute('x2', endPoint.x); line.setAttribute('y2', endPoint.y);
                line.setAttribute('stroke', '#94a3b8'); line.setAttribute('stroke-width', scale);
                svg.appendChild(line);

                // Level markers
                dim.levels.forEach((level, levelIdx) => {
                    const distance = minRadius + (levelIdx / (dim.levels.length - 1)) * (maxRadius - minRadius);
                    const point = getPoint(angle, distance);
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', point.x); circle.setAttribute('cy', point.y);
                    circle.setAttribute('r', 5 * scale);
                    circle.setAttribute('fill', 'white');
                    circle.setAttribute('stroke', '#475569');
                    circle.setAttribute('stroke-width', scale);
                    svg.appendChild(circle);

                    if (state.theme.showLevelLabels) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', point.x); text.setAttribute('y', point.y);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('dominant-baseline', 'middle');
                        text.setAttribute('font-size', 12 * scale);
                        text.setAttribute('fill', '#1e293b');
                        text.setAttribute('stroke', 'white');
                        text.setAttribute('stroke-width', 3 * scale);
                        text.setAttribute('paint-order', 'stroke');
                        text.textContent = level.name;
                        svg.appendChild(text);
                    }
                });

                if (state.theme.showDimensionNames) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', endPoint.x); text.setAttribute('y', endPoint.y);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('font-size', 14 * scale);
                    text.setAttribute('font-weight', '600');
                    text.setAttribute('fill', '#1e293b');
                    text.textContent = dim.name;
                    svg.appendChild(text);
                }
            });

            // LAYER 3: Drag Handles (On top of everything)
            if (interactive) {
                visibleDataPoints.forEach((dp, dpIdx) => {
                    const color = colors[dpIdx % colors.length];

                    const points = state.dimensions.map((dim, idx) => {
                        const angle = getAngle(idx, state.dimensions.length);
                        const levelValue = dp.values[dim.id] || 0;
                        const distance = minRadius + (levelValue / (dim.levels.length - 1)) * (maxRadius - minRadius);
                        return { ...getPoint(angle, distance), dimId: dim.id, levelValue };
                    });

                    points.forEach((p) => {
                        const dim = state.dimensions.find(d => d.id === p.dimId);
                        if (!dim) return;

                        const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        handle.setAttribute('cx', p.x);
                        handle.setAttribute('cy', p.y);
                        handle.setAttribute('r', 8 * scale); // Larger target
                        handle.setAttribute('fill', color);
                        handle.setAttribute('stroke', 'white');
                        handle.setAttribute('stroke-width', 2 * scale);
                        handle.setAttribute('cursor', 'grab');
                        handle.setAttribute('class', 'drag-handle');

                        // Accessibility attributes
                        handle.setAttribute('tabindex', '0');
                        handle.setAttribute('role', 'slider');
                        handle.setAttribute('aria-label', `${dp.name}: ${dim.name}`);
                        handle.setAttribute('aria-valuemin', '0');
                        handle.setAttribute('aria-valuemax', dim.levels.length - 1);
                        handle.setAttribute('aria-valuenow', p.levelValue);
                        handle.setAttribute('aria-valuetext', dim.levels[p.levelValue].name);

                        // Identification for focus restoration
                        handle.setAttribute('data-dp-idx', dpIdx);
                        handle.setAttribute('data-dim-id', p.dimId);

                        // Event listener for drag start
                        handle.addEventListener('mousedown', (e) => startDrag(e, dpIdx, p.dimId));

                        // Event listener for keyboard
                        handle.addEventListener('keydown', (e) => handleKeyDown(e, dpIdx, p.dimId));

                        svg.appendChild(handle);
                    });
                });
            }

            container.innerHTML = '';
            container.appendChild(svg);
            return svg;
        }

        function renderChart() {
            const svg = renderRadarChart(document.getElementById('chartView'), 1, true);
            renderLegend();
        }

        function renderExportPreview() {
            renderRadarChart(document.getElementById('chartExport'), 0.5, false);
        }

        function renderLegend() {
            const container = document.getElementById('chartLegend');
            const visibleDataPoints = state.dataPoints.filter(dp => dp.visible);
            const colors = colorSchemes[state.theme.colorScheme];
            const patterns = ['solid', 'horizontal', 'vertical', 'diagonal-right', 'diagonal-left', 'crosshatch', 'dots'];

            if (visibleDataPoints.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = visibleDataPoints.map((dp, idx) => {
                const color = colors[idx % colors.length];
                return `
                    <div class="legend-item">
                        <div class="legend-swatch" style="background: ${color}; opacity: 0.5; border-color: ${color};"></div>
                        <span>${dp.name}</span>
                    </div>
                `;
            }).join('');
        }

        // Documentation
        function renderDocumentation() {
            const container = document.getElementById('documentationContent');
            
            if (state.dimensions.length === 0) {
                container.innerHTML = '<div class="empty-state">Add dimensions to see documentation tables.</div>';
                return;
            }

            let html = '';
            if (state.description) {
                html += `<div class="info-box">${state.description}</div>`;
            }

            html += state.dimensions.map(dim => `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                        <div>
                            <h3>${dim.name}</h3>
                            ${dim.description ? `<p style="font-size: 0.875rem; color: #64748b; margin-top: 0.25rem;">${dim.description}</p>` : ''}
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-primary" onclick="copyTableHTML(${dim.id})">Word</button>
                            <button class="btn btn-success" onclick="copyTableLaTeX(${dim.id})">LaTeX</button>
                        </div>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Level Name</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${dim.levels.map(level => `
                                <tr>
                                    <td>${level.name}</td>
                                    <td>${level.description || ''}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `).join('');

            container.innerHTML = html;
        }

        function copyTableHTML(dimId) {
            const dim = state.dimensions.find(d => d.id === dimId);
            const html = `<h2>${dim.name}</h2>
${dim.description ? `<p>${dim.description}</p>` : ''}
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; width: 100%;">
<thead>
<tr>
<th style="background-color: #f0f0f0; text-align: left; padding: 8px;">Level Name</th>
<th style="background-color: #f0f0f0; text-align: left; padding: 8px;">Description</th>
</tr>
</thead>
<tbody>
${dim.levels.map(level => `<tr>
<td style="padding: 8px;">${level.name}</td>
<td style="padding: 8px;">${level.description || ''}</td>
</tr>`).join('\n')}
</tbody>
</table>`;
            
            navigator.clipboard.writeText(html).then(() => alert('HTML table copied!'));
        }

        function copyTableLaTeX(dimId) {
            const dim = state.dimensions.find(d => d.id === dimId);
            const latex = `\\begin{table}[h]
\\centering
\\caption{${dim.name}${dim.description ? `: ${dim.description}` : ''}}
\\begin{tabular}{|l|p{10cm}|}
\\hline
\\textbf{Level Name} & \\textbf{Description} \\\\ \\hline
${dim.levels.map(level => `${level.name} & ${level.description || ''} \\\\ \\hline`).join('\n')}
\\end{tabular}
\\end{table}`;
            
            navigator.clipboard.writeText(latex).then(() => alert('LaTeX table copied!'));
        }

        // Alt text and caption
        function generateAltText() {
            const visibleDataPoints = state.dataPoints.filter(dp => dp.visible);
            const dimList = state.dimensions.map(d => d.name).join(', ');
            
            let text = `A radar chart titled "${state.chartTitle}"`;
            if (state.description) text += ` representing ${state.description}`;
            text += ` displaying ${state.dimensions.length} dimensions: ${dimList}.`;
            
            if (visibleDataPoints.length > 0) {
                text += ` The chart shows ${visibleDataPoints.length} data point${visibleDataPoints.length > 1 ? 's' : ''}: `;
                text += visibleDataPoints.map(dp => {
                    const values = state.dimensions.map(dim => {
                        const level = dim.levels[dp.values[dim.id] || 0];
                        return `${dim.name}: ${level.name}`;
                    }).join(', ');
                    return `${dp.name} (${values})`;
                }).join('; ');
                text += '.';
            }
            
            document.getElementById('altText').textContent = text;
            document.getElementById('altTextDisplay').style.display = 'block';
        }

        function generateCaption() {
            const visibleDataPoints = state.dataPoints.filter(dp => dp.visible);
            
            let text = `Figure: ${state.chartTitle}.`;
            if (state.description) text += ` ${state.description}`;
            
            text += ' This radar chart ';
            
            if (visibleDataPoints.length === 0) {
                text += 'presents the design space framework';
            } else if (visibleDataPoints.length === 1) {
                text += `presents the profile of ${visibleDataPoints[0].name}`;
            } else if (visibleDataPoints.length === 2) {
                text += `compares ${visibleDataPoints.map(dp => dp.name).join(', ')}`;
            } else {
                text += `compares ${visibleDataPoints.length} configurations (${visibleDataPoints.map(dp => dp.name).join(', ')})`;
            }
            
            text += ` across ${state.dimensions.length} dimensions.`;
            
            document.getElementById('caption').textContent = text;
            document.getElementById('captionDisplay').style.display = 'block';
        }

        function copyText(id) {
            const text = document.getElementById(id).textContent;
            navigator.clipboard.writeText(text).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = originalText, 2000);
            });
        }

        // Import/Export
        function exportJSON() {
            const config = {
                chartTitle: state.chartTitle,
                description: state.description,
                dimensions: state.dimensions,
                dataPoints: state.dataPoints,
                theme: state.theme
            };
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${state.chartTitle.replace(/\s+/g, '_')}_config.json`;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        function importJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const config = JSON.parse(e.target.result);
                    state = {
                        chartTitle: config.chartTitle || 'Design Space',
                        description: config.description || '',
                        dimensions: config.dimensions || [],
                        dataPoints: config.dataPoints || [],
                        theme: config.theme || {
                            width: 800,
                            height: 800,
                            showLevelLabels: true,
                            showDimensionNames: true,
                            colorScheme: 'default'
                        }
                    };
                    
                    document.getElementById('titleInput').value = state.chartTitle;
                    document.getElementById('descInput').value = state.description;
                    document.getElementById('titleDisplay').textContent = state.chartTitle;
                    document.getElementById('descDisplay').textContent = state.description;
                    document.getElementById('chartWidth').value = state.theme.width;
                    document.getElementById('chartHeight').value = state.theme.height;
                    document.getElementById('showLevelLabels').checked = state.theme.showLevelLabels;
                    document.getElementById('showDimensionNames').checked = state.theme.showDimensionNames;
                    
                    saveState();
                    render();
                    alert('Configuration imported successfully!');
                } catch (error) {
                    alert('Failed to import configuration. Please check the file format.');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function exportSVG() {
            const container = document.getElementById('chartExport');
            const svg = container.querySelector('svg');
            
            if (!svg) {
                alert('Please ensure the chart has been rendered.');
                return;
            }
            
            const svgClone = svg.cloneNode(true);
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

            // Add Legend to SVG for Export
            const visibleDataPoints = state.dataPoints.filter(dp => dp.visible);
            if (visibleDataPoints.length > 0) {
                const originalHeight = parseInt(svgClone.getAttribute('height'));
                const originalWidth = parseInt(svgClone.getAttribute('width'));
                const legendHeight = Math.ceil(visibleDataPoints.length / 2) * 30 + 40; // Estimate height
                const newHeight = originalHeight + legendHeight;

                svgClone.setAttribute('height', newHeight);
                svgClone.setAttribute('viewBox', `0 0 ${originalWidth} ${newHeight}`); // Preserve scaling if any

                const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                legendGroup.setAttribute('transform', `translate(0, ${originalHeight})`);

                const colors = colorSchemes[state.theme.colorScheme];

                visibleDataPoints.forEach((dp, idx) => {
                    const color = colors[idx % colors.length];
                    const x = (idx % 2) * (originalWidth / 2) + 20; // 2 columns
                    const y = Math.floor(idx / 2) * 30 + 20;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', y);
                    rect.setAttribute('width', '20');
                    rect.setAttribute('height', '20');
                    rect.setAttribute('fill', color);
                    rect.setAttribute('stroke', color);
                    rect.setAttribute('rx', '4'); // Rounded corners

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x + 30);
                    text.setAttribute('y', y + 15); // Vertically centered
                    text.setAttribute('font-size', '14');
                    text.setAttribute('fill', '#1e293b');
                    text.textContent = dp.name;

                    legendGroup.appendChild(rect);
                    legendGroup.appendChild(text);
                });

                svgClone.appendChild(legendGroup);
            }
            
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgClone);
            const blob = new Blob([svgString], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${state.chartTitle.replace(/\s+/g, '_')}.svg`;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        // Main render
        function render() {
            renderDimensions();
            renderDataPoints();
            renderColorSchemes();
            renderChart();
        }

        // Initialize on load
        init();
    </script>
</body>
</html>